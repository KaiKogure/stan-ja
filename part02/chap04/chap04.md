## 4. データ格納形式: `Arrays`, `Vectors`, and `Matrices`
Stanには`arrays`, `vectors`, `matrices` 3種のデータ格納型が用意されており、データ型の間でデータを互いに入れ替えることはできません。これは、たとえデータの次元が一致していても同様です。Stanにおいて、3 × 4次元の`matrix`は3 × 4次元の`array`とは全く別種類のオブジェクトなのです。

### 4.1. `Vectors` and `Matrices`
`Vectors`, `Matrices`は`Arrays`に比べると、単純なデータ構造になっています。`Vectors`は1次元の実数を、`Matrices`は2次元の実数を取り扱うためのデータ格納型です。`Matrices`型の用途として、コード内で`Matrices`内のデータを読み出すことが挙げられます。Stanにおいて、`Vectors`,` Matrices`型を使うのはおそらく以下の3つの場合のみでしょう。
1. 行列演算 (行列の乗算など)
2. 線形代数周りの機能 (固有値, 行列式など)
3. 多変量パラメータ, アウトカムの取り扱い (多変量正規分布の引数など)
`Vectors`, `Matrices`は整数値を返すことはできず、取り扱えるのは`real`に限られています。

### 4.2. `Arrays`
`Arrays`は、基本的には1次元のデータを扱うためのオブジェクトです。`Arrays`には単純な実数や整数値、`Vectors`、`Matrices`、別の`Arrays`のような、あらゆるデータ型の値を格納することができます。`Arrays`はStanにおいて唯一、整数のシーケンスを代入可能なデータ型です。整数のシーケンスが必要な状況として、離散分布の指定などが挙げられます。　　
2次元の`Arrays`はいわば`Arrays`を並べたものとして扱うことができます。インデックスを`Array`に与えると、`Array`はそのインデックスの値を返します。複数のインデックスをArrayに与えると、連鎖的にインデックス付けが行われます。例えばこれを利用して、`a[m][n]`という２次元`array`を、`a[m,n]`と簡単に記述することができます。

### 4.3. 上手い使い分け方
Stanの目指す基本設計の方向性の1つとして、効率よく計算を進めることが挙げられます。
Stanにおいて、行列、線形代数の操作に関わる動作は`Eigen C++`ライブラリのデータ型をベースに実装されています。このため、行列、線形代数の機能を使用する際`Vectors`, `Matrices`を型としていれば、データ型を変換する必要はありません。
一方、`Arrays`はC++の一般的な`vector`クラスのインスタンスとして実装されています。(Eigenライブラリの`Eigen::Vector`クラスや、 Stanの`Vectors`と混同しないように注意しましょう)。`Arrays`はこのように実装されているため、値を参照して返すことができます。このため値のコピーに比べ、非常に効率よくインデックス付けを実行できます。

#### `Matrices` vs. `2次元Arrays`
Stanモデルにおける2次元アレイと`Matrices`の使い分けについて考慮すべき点を以下に示します。
第1に、`Matrices`は2次元`Arrays`よりもメモリの使用量が少ない点です。これは、`Matrices`では、`Arrays`のシーケンスを保存せず、データと2次元形式のみを保存しているためです。第2に、`Matrices`は列データを優先して格納する仕組みである点です。`Matrices`内のすべてのデータはメモリ内で隣接することが保証されます。一般的に、メモリにキャッシュされたデータを直接取り扱うことで、最新のCPUを使った算術演算よりもはるかに高速に計算を行うことができます。このため、データ型の仕組みを理解して使い分けをすることは、コードを最適化する上で重要な事項となります。
一方、`Arrays`はプリミティブ型の値をメモリ内で隣接することを保証しており、それ以外の場合はその値のコピーを保持するように設計されています（可能な限り値を参照するように返す）。
第3に、いずれのデータ構造もそれらが保存されている順序でトラバースされる点です。これはメモリ参照の局所性を有効活用する際に重要になります。`Matrices`では列が優先されるため、以下のような記述が適切です。

```
  matrix[M,N] a;
  //...
  for (n in 1:N)  //列が先
    for (m in 1:M)  //行が後
      // ... a[m,n]を使った計算...
```

`Arrays`では行が優先されるため、以下のような記述が適切です。

```
  real a[M,N];
  // ...
  for (m in 1:M)  //行が先
    for (n in 1:N)  //列が後
      // ... a[m,n]を使った計算...
```

最初に`a[m,n]`を使う際には、`a[m]`をメモリに受け渡すようにしましょう。一般的に、`Matrices`をトラバースする方が、`Arrays`をトラバースするよりも効率が良いです。これは`Matrices`内の`Arrays`についても同様です。以下に`Matrices`の2次元`Arrays`の理想的な記述例を示します。

```
  matrix[M,N] b[I,J];
  // ...
  for (i in 1:I)  //`Array`なので行が先
    for (j in 1:J)  //`Array`なので列が後
      for (n in 1:N)  //`Matrix`なので列が先
        for (m in 1:M) //`Matrix`なので行が後
          //... `b[i,j,m,n]` を使った計算...
```

`Matrices`の場合、`a[m]`と表記するとその`Matrices`の行`m`が抽出されますが、これは`Matrices`を取り扱う上では非効率な操作です。ベクトルのインデックスを作る必要があるなら、以下のように`Arrays`のベクトルを宣言する方がはるかに効率的です。

```
  row_vector[N] b[M];
  // ...
  for (m in 1:M)
    //... `row vector` `b[m]`を使った計算 ...
```

これは以下の`matrix`を使った例よりも圧倒的に優れています。

```
  matrix b[M,N];
  // ...
  for (m in 1:M)
    // ... `row vector` `b[m]`を使った計算  ...
```

同様に、列ベクトルの`Array`を作成することで、`matrix`の列を選択する`col`関数を使うよりも効率よく列を指定することができます。対照的に、`matrix`を使うと純粋に線形代数の計算を解くことになるため、演算を高速化することができます。もし予測係数のドット積の列を作成する場合、以下のように記述することで、

```
  matrix[N,K] x; // `predictors (aka covariates)`
  // ...
  vector[K] beta; // `coeffs`
  // ...
  vector[N] y_hat; // `linear prediction`
  // ...
  y_hat <- x * beta;
```

  以下のように書くよりも効率よく列を作ることができます。

```
  row_vector[K] x[N]; // predictors (aka covariates)
  // ...
  vector[K] beta; // coeffs
  ...
  vector[N] y_hat; // linear prediction
  ...
  for (n in 1:N)
    y_hat[n] <- x[n] * beta;
```

#### 列`Vectors` vs. 1次元`Arrays`
純粋にコンテナとして使用する上では、列`Vectors`と1次元`Arrays`の間に大きな違いはありません。`Eigen:Vector`テンプレートと、`C++`の`std:vector`テンプレートクラスは、`double`型の値のコンテナとして非常に近い形で実装されています (Stanでは`real`型)。Stanにおいて`Arrays`に入力できるのは整数値のみです。
