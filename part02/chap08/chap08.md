## 8. 欠測データと部分的に既知のパラメータ
**訳語は、欠測データ? 欠損データ?**

ベイズ推定では欠測データにはごく一般的な手法を使えます。つまり、欠測データの項目すべてが、事後分布で推定されるパラメータとして表されます(Gelman et al., 2013)。欠測データが明示的にモデル化されないのであれば、たいていの回帰モデルの予測変数でそうですが、結果は、欠測予測変数を表すパラメータについての非正則事前分布となります(**訳:「非正則事前分布のままです」?**)。

観測データと欠測データとの混合配列はStanに取り入れるのは難しいことがあります。これは一部には、離散の未知量をモデル化する方法がStanではトリッキーなことがあることによりますし、また一部には、ほかのいくつかの統計言語（例えば、RやBUGS）とは違ってStanでは、観測量と未知量はモデル中の別の場所で定義する必要があることによります。そのため、Stanプログラムでは、データ構造のうちの観測部分と欠測部分とを組み合わせるコードを含める必要があることがあります。例はこの章でこの後から紹介します。

### 8.1. 欠測データ

Stanでは、`data`と`transformed data`ブロックで宣言された変数を既知と、`parameters`ブロックで宣言された変数を未知として扱います。

正規観測値の欠測データを含む例<sup>1</sup>は以下のようにコーディングできるでしょう。

```
data {
  int<lower=0> N_obs;
  int<lower=0> N_mis;
  real y_obs[N_obs];
}
parameters {
  real mu;
  real<lower=0> sigma;
  real y_mis[N_mis];
}
model {
  for (n in 1:N_obs)
    y_obs[n] ~ normal(mu,sigma);
  for (n in 1:N_mis)
    y_mis[n] ~ normal(mu,sigma);
}
```

観測データ点と欠測データ点の数はデータとして非負の整数の変数`N_obs`と`N_mis`としてコーディングされています。観測データは、`array`型のデータの変数`y_obs`として与えられています。欠測データは`array`型のパラメータ`y_mis`としてコーディングされています。通常のパラメータが推定されるように、位置`mu`とスケール`sigma`もパラメータとしてコーディングされています。このモデルをもっとうまく書く方法はベクトル化することです。そうすると本体は次のようになります。

```
  y_obs ~ normal(mu,sigma);
  y_mis ~ normal(mu,sigma);
```

このモデルには、観測データと欠測データにそれぞれ1つのループがあります。これはモデル指定としていささか冗長ですが、そのおかげで、Stanでの欠測データ問題としては、次の節で記述するもっと一般的なテクニックよりもはるかに効率的なサンプリングが可能になります。

<sup>1</sup>もっと意味のある推定例は、観測された観測値と欠測の観測値についての回帰を含むものでしょう。これには、それぞれについて既知で、`data`ブロックで指定された予測変数を使用します。（**ここはよくわかりません**）

8.2. 部分的に既知のパラメータ

多変量確率関数で、一部の結果やパラメータだけが観測されているいったような状況では、既知量（データ）と未知量（パラメータ）とを混ぜたベクトルを作る必要があります。Stanでこれをおこなうのは、`transformed parameters`ブロックでベクトルあるいは配列をつくり、それに割り当てることにより可能です。

以下の例は、2変数の共分散行列を含むもので、分散は既知ですが、共分散はそうではありません。

```
data {
  int<lower=0> N;
  vector[2] y[N];
  real<lower=0> var1;     real<lower=0> var2;
}
transformed data {
  real<upper=0> min_cov;
  real<lower=0> max_cov;
  max_cov <- sqrt(var1 * var2);
  min_cov <- -max_cov;
}
parameters {
  vector[2] mu;
  real<lower=min_cov,upper=max_cov> cov;
}
transformed parameters {
  matrix[2,2] sigma;
  sigma[1,1] <- var1;
  sigma[2,1] <- cov;
}
model {
  for (n in 1:N)
    y[n] ~ multi_normal(mu,sigma);
}
```

分散は、変数`var1`および`var2`にデータとして定義されていますが、共分散は、変数`cov`にパラメータとして定義されています。2×2共分散行列`sigma`は変換パラメータ(transformed parameter)として定義されています。分散は、2つの対角要素に割り当てられ、共分散は、2つの非対角要素に割り当てられます。

共分散の宣言につけた制約により、結果の共分散行列`sigma`が正定値であることが保証されます。分散の積の正負の平方根が上下限となりますが、この値は`transformed data`として定義されるので、1度だけ計算されます。

8.3. 効率性についての覚書

はじめの節の欠測データの例は、次の節の、部分的に既知のパラメータの例の方法に従って、データとパラメータを混ぜた配列としてプログラミングすることもできるでしょう。正しく動くでしょうが、計算には無駄が多くなります。`parameters`あるいは`transformed parameters`ブロックで宣言される各パラメーターは自動微分の変数を使います。単純なデータの変数と比較すると、記憶容量と勾配計算の時間の点でこれは高くつきます。さらに、そのコピーが余分な要領と余分な時間を使います。

8.4. 因子分析の負荷行列

Rick Farouniは、Stan users groupで、単位対角の共分散行列についてCholesky因子をつくる方法を尋ねました。これは、ベイズ因子分析(Aguilar and West 2000)で使われます。対角下の要素をパラメータとして宣言し、それから行列全体を変換パラメータ(tranformed parameter)として満たすことで、これを行なうことができます。

```
data {
  int<lower=2> K;
}
transformed data {
  int<lower=1> K_choose_2;
  K_choose_2 <- (K * (K - 1)) / 2;
}
parameters {
  vector[K_choose_2] L_lower;
}
transformed parameters {
  cholesky_factor_cov[K] L;
  for (k in 1:K)
    L[k,k] <- 1;
  {
    int i;
    for (m in 2:K) {
      for (n in 1:(m - 1)) {
        L[m,n] <- L_lower[i];
        L[n,m] <- 0;
        i <- i + 1;
      }
    }
  }
}
```

`L_lower`に事前分布を直接置くのが最も便利です。もうひとつの方法は、Cholesky因子`L`全体への事前分布でしょう。`L_lower`から`L`への変換では値は変わらないので、Jacobian調整(adjustment)を必要としないからです（パーサから警告が出ますが、変換が線形であると推定するコード解析にはあまりスマートでありません）。共分散行列`L * L'`全体に事前分布を置くのは全然便利ではないでしょう。Jacobian調整が必要となるでしょうし。正確な調整は、共分散行列を扱う56.1節の小節で示します。
