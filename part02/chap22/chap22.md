## 22.再現性(Reproducibility)について

現代のコンピュータにおける浮動小数点演算は，IEEE754に準拠した基礎的な数値演算が完全には規定されていないため，追試が難しいことで有名です。根本的な問題点は演算の精度がハードウェアプラットフォームやソフトウェアの実装により異なっていることにあります。
Stanは完全な再現性を許容すべく設計されています。しかしながら，それはあくまで浮動小数点計算により課せられた外的制約により左右されます。

Stanの結果は以下のすべての要素が一致しているときにのみ厳密に再現可能となります：

- Stanのバージョン
- Stanのインターフェイス(Rstan, PyStan, CmdStan) およびそのバージョン，さらにインターフェイス言語(R, Python, shell)のバージョン
- インクルードされたライブラリのバージョン(BoostおよびEigen)
- OSのバージョン
- CPU，マザーボード，メモリを含むコンピュータのハードウェア
- C++コンパイラのバージョン，コンパイル時のフラグ，リンクされたライブラリ
- 乱数の種，チェーンのID，初期化およびデータを含むStan呼び出し時の設定

これはStanの安定リリースを使っているか，特定の **`` Git hash tag  - Gitの特定のバージョンくらいに訳してしまってもよい？``** を使っているかには関係ありません。インターフェイスやコンパイラについても同様です。重要なのはもしこれらのどれか一つでも何らかの違いがあれば，浮動小数点計算の結果は変わる可能性があるということです。

具体的には，もしあるStanプログラムをCmdStanでコンパイルするときに，最適化フラグを変更(-O3 とか -O2 または -O0)した場合，これらの一連の結果は必ずしも一致しません。このため，クラスターやIT部門に管理されたデスクトップ，自動更新がONになっているなど外部に管理されたハードウェア上で再現性を保証するのは極めて困難です。

しかしながら，もしStanプログラムを一組のフラグを使ってコンパイルし，そのコンピュータをインターネットから取り外して一切アップデートしないようにし，10年後に戻ってきて同じように再コンパイルした場合，同じ結果が得られます。

データについても **`bit level - ビットレベルとしてもよい？`** で同じである必要があります。例えば，もしRStanであればRcppがRの浮動小数点小数とC++の倍精度小数の変換を行います。もしRcppが変換のプロセスを変更したり異なる型を使うと，結果は **`bit level `** で同じであることは保証されません。

コンパイラとコンパイラの設定も同じ問題を起こす可能性があります。インテル製コンパイラで再現性をいかにコントロールするかについての素敵な議論はCoden and Kreirzer(2014)を読んでください。 

**`PDFに埋められたBibliographyへのリンクはどう扱う？`**

リンク先のBibliography

>Corden, M. J. and Kreitzer, D. (2014). Consistency of floating-point results using the Intel compiler or Why doesn’t my application always give the same answer? Technical report, Intel Corporation. 
